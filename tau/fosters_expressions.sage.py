

# This file was *autogenerated* from the file fosters_expressions.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_6 = Integer(6); _sage_const_12 = Integer(12); _sage_const_50 = Integer(50)# Various functions involving Fosters Coefficients
load('tau.sage')

def single_integral_second_term_without_discrete(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return {(e[_sage_const_0 ],e[_sage_const_1 ]):e[_sage_const_2 ] * F[e] * (R[_sage_const_0 ,e[_sage_const_0 ]] + R[_sage_const_0 ,e[_sage_const_1 ]]) for e in E}

def single_integral_term_without_discrete(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return {(e[_sage_const_0 ],e[_sage_const_1 ]): _sage_const_1 /_sage_const_6  *F[e]**_sage_const_2 *e[_sage_const_2 ]**_sage_const_2  + _sage_const_1 /_sage_const_2 *e[_sage_const_2 ] * F[e] * (R[_sage_const_0 ,e[_sage_const_0 ]] + R[_sage_const_0 ,e[_sage_const_1 ]]) for e in E}

def single_integral_without_discrete(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return sum(_sage_const_1 /_sage_const_6  *F[e]**_sage_const_2 *e[_sage_const_2 ]**_sage_const_2  + _sage_const_1 /_sage_const_2 *e[_sage_const_2 ] * F[e] * (R[_sage_const_0 ,e[_sage_const_0 ]] + R[_sage_const_0 ,e[_sage_const_1 ]])
               for e in E)

# Above is in output_without_discrete.txt

def single_integral_first_term(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return {(e[_sage_const_0 ],e[_sage_const_1 ]):F[e]**_sage_const_2 *e[_sage_const_2 ]**_sage_const_2  for e in E}

def single_integral_second_term(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return {(e[_sage_const_0 ],e[_sage_const_1 ]):((_sage_const_1 /G.degree(e[_sage_const_0 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e] ) * R[_sage_const_0 ,e[_sage_const_0 ]] + (_sage_const_1 /G.degree(e[_sage_const_1 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_1 ]]) for e in E}

def single_integral_term(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return {(e[_sage_const_0 ],e[_sage_const_1 ]): _sage_const_1 /_sage_const_6  *F[e]**_sage_const_2 *e[_sage_const_2 ]**_sage_const_2  +  ((_sage_const_1 /G.degree(e[_sage_const_0 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_0 ]] + (_sage_const_1 /G.degree(e[_sage_const_1 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_1 ]]) for e in E}

def single_integral(G):
    E = G.edges()
    R = resistance_matrix(G)
    F = fosters(G,R)
    return sum(_sage_const_1 /_sage_const_6  *F[e]**_sage_const_2 *e[_sage_const_2 ]**_sage_const_2  + ((_sage_const_1 /G.degree(e[_sage_const_0 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_0 ]] + (_sage_const_1 /G.degree(e[_sage_const_1 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_1 ]]) for e in E) 

# Above is in output_with_discrete.txt

def F_R_l_star(G):
    R = resistance_matrix(G)
    F = fosters(G,R)
    ans = {v:_sage_const_0  for v in G.vertices()}
    for e in G.edges():
        ans[e[_sage_const_0 ]] += R[_sage_const_0 ,e[_sage_const_0 ]] * F[e] * e[_sage_const_2 ]
        ans[e[_sage_const_1 ]] += R[_sage_const_0 ,e[_sage_const_1 ]] * F[e] * e[_sage_const_2 ]
    return ans

def second_term_star(G):
    R = resistance_matrix(G)
    F = fosters(G,R)
    ans = {v:_sage_const_0  for v in G.vertices()}
    for e in G.edges():
        ans[e[_sage_const_0 ]] += (_sage_const_1 /G.degree(e[_sage_const_0 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_0 ]]
        ans[e[_sage_const_1 ]] += (_sage_const_1 /G.degree(e[_sage_const_1 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_1 ]]
    return ans

def both_terms_star(G):
    R = resistance_matrix(G)
    F = fosters(G,R)
    ans = {v:_sage_const_0  for v in G.vertices()}
    for e in G.edges():
        ans[e[_sage_const_0 ]] += (_sage_const_1 /G.degree(e[_sage_const_0 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_0 ]] + _sage_const_1 /_sage_const_12  * F[e]**_sage_const_2  * e[_sage_const_2 ]**_sage_const_2 
        ans[e[_sage_const_1 ]] += (_sage_const_1 /G.degree(e[_sage_const_1 ]) - _sage_const_1 /_sage_const_2  + _sage_const_1 /_sage_const_2  * e[_sage_const_2 ] * F[e]) * R[_sage_const_0 ,e[_sage_const_1 ]] + _sage_const_1 /_sage_const_12  * F[e]**_sage_const_2  * e[_sage_const_2 ]**_sage_const_2 
    return ans

#Above is in output_of_stars.txt

# ABOVE IS OLD TERMS ALREADY TESTED

# def vertex_first_term(G):
#     V = G.vertices()
#     R = resistance_matrix(G)
#     F = fosters(G,R,labels=False)
#     ans = {v:0 for v in G.vertices()}
#     for v in V:
#         for 
#         ans[v] = (1/G.degree(v) - 1/2 + 1/2 * 
#     return ans

def test(G):
    E = G.edges()
    V = G.vertices()

    print("F R l star")
    F = to_function(F_R_l_star,G)
    L = convexity_test_vertex_dictionary(F,V,len(E),test_num=_sage_const_50 )
    print({v for v in L.keys() if L[v]})

    print("second term star")
    F = to_function(second_term_star,G)
    L = convexity_test_vertex_dictionary(F,V,len(E),test_num=_sage_const_50 )
    print({v for v in L.keys() if L[v]})

    print("both term star")
    F = to_function(both_terms_star,G)
    L = convexity_test_vertex_dictionary(F,V,len(E),test_num=_sage_const_50 )
    print({e for e in L.keys() if L[e]})

