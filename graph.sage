from inspect import signature
from sage.misc.prandom import uniform

# Visualize graph G
def visualize(G):
    H = G.plot(edge_labels=True)
    return H

def assignVariables(G):
    G.allow_multiple_edges(True)
    polys = PolynomialRing(QQ,len(G.edges()),"z").fraction_field()
    z = polys.gens()
    i = 0
    for u,v in G.edges(labels=0):
        G.set_edge_label(u,v,z[i])
        i += 1
    return polys

# Implimenting https://onlinelibrary.wiley.com/doi/10.1002/net.1975.5.3.237
# TODO  https://sci-hubtw.hkvisa.net/10.1002/net.1975.5.3.237
# https://www.w3schools.com/python/python_iterators.asp
def set_of_spanning_trees(G):
    if not G.connected():
        return {}

# TODO
def set_of_spanning_trees_helper(G):
    return {}

# TODO
def convexity_test(f, lower_bound = 0, upper_bound = 1, test_num = 500):
    param_num = len(signature(f).parameters)
    x1 = []
    x2 = []
    for i in range(test_num):
        x1 = [uniform(0,1) for i in range(param_num)]
        x2 = [uniform(0,1) for i in range(param_num)]
        xm = [(x1[i] + x2[i])/2 for i in range(param_num)]
        y1 = N((f(*x1) + f(*x2))/2, digits=6)
        y2 = N(f(*xm), digits=6) - .000001
        if y1 < y2:
            print("Failed test: ")
            print("y1 < y2 = " + str(y1 < y2))
            print("x1 = " + str(x1))
            print("x2 = " + str(x2))
            print("xm = " + str(xm))
            print("y1 = " + str(y1))
            print("y2 = " + str(y2))
            return False
    return True
        

# Returns the Canonical Divisor for G as a dictionary 
# of the form {vertex v: integer D(v)}
def canonical_divisor(G):
    V = G.vertices()
    D = {v:0 for v in V}
    for v in V:
        D[v] = G.degree(v) - 2
    return D

# Returns the edges incident to vertex v
def star(v, G):
    S = set()
    for e in G.edges():
        if v in e:
            S.add(e)
    return S

# Returns the resulting divisor after chip firing at vertex v
def vertex_fire(v, D, G):
    D[v] = D[v] - G.degree(v)
    for e in star(v, G):
        w = filter(lambda s: s != v, e)[0]
        D[w] = D[w] + 1
    return D

# Returns the resulting divisor after chip firing at vertex set S
def fire(S, D, G):
    for v in S:
        D = vertexFire(v,D,G)
    return D

# Returns the laplacian_matrix with edge weights treated as resistances 
# i.e L[i,i] = sum over e incident to i of 1/r(e)
# i.e L[i,j] = 1/r(e) where e = (i,j)
def laplacian_matrix(G,polys):
    n = len(G.vertices())
    L = matrix(polys,n,n)
    for e in G.edges():
        i = e[0]
        j = e[1]
        L[i,i] += 1/e[2]
        L[j,j] += 1/e[2]
        L[i,j] -= 1/e[2]
        L[j,i] -= 1/e[2]
    return L

# As done in 4.3 of Metric graphs, cross ratios, and Rayleigh's laws
# Returns the matrix with (x,y) entry equal to j_q(x,y)
# polys is the fraction field containing the resistances on G
def j_functions(q, G, polys):
    L = laplacian_matrix(G,polys)
    Lq = L.delete_columns([q]).delete_rows([q])
    n = Lq.dimensions()[0]
    Q = Lq.inverse()
    rows = Q.rows()
    rows[q:q] = [(0,)*n]
    Q = matrix(rows)
    rows = Q.transpose().rows()
    rows[q:q] = [(0,)*(n+1)]
    Q = matrix(rows).transpose()
    return Q

# Returns effective resistance between vertices v and w
# polys is the fraction field containing the resistances on G
def res(v,w,G, polys):
    return j_functions(v,G, polys)[w,w]

# Returns Foster's coefficient of given edge
# polys is the fraction field containing the resistances on G
def fosters(G):
    W = 0
    E = set(G.edges())
    F = {e:0 for e in G.edges()}
    print("spanning_trees = %i" %G.spanning_trees_count())
    count = 1
    for T in G.spanning_trees(labels = True):
        if count % 10000 == 0:
            print("count = %i" %count)
        count += 1
        p = 1
        S = E.copy()
        for s in T.edges():
            S.remove(s)
        for e in S:
            w = e[2]
            p *= w
        for e in S:
            w = e[2]
            F[e] += p
        W += p
    for e in G.edges():
        F[e] = F[e]/W
    return F

# Performs series reduction to graph with edges e and w in series
def series_reduction(e, w, G):
    G.allow_multiple_edges(True)
    G = copy(G)
    r1 = e[2]
    r2 = w[2]
    verticies = list({e[0], e[1]} ^^ {w[0], w[1]})
    if len(verticies) != 2:
        print("Cannot perform series reduction (edges not incident)")
        return 
    v = list({e[0], e[1]} & {w[0], w[1]})[0]
    if G.degree(v) != 2:
        print("Cannot perform series reduction (edges not a bridge)")
        return
    G = copy(G)
    G.delete_edges([e,w])
    G.add_edge(([verticies[0], verticies[1], r1 + r2]))
    G.delete_vertex(v)
    return G

# Performs parallel reduction to graph with edges e and w in parallel
def parallel_reduction(e, w, G):
    G.allow_multiple_edges(True)
    vs = list({e[0], e[1]} & {w[0], w[1]})
    if len(vs) != 2:
        print("Cannot perform parallel reduction (edges not parallel)")
        return
    G = copy(G)
    r1 = e[2]
    r2 = w[2]
    G.delete_edges([e,w])
    G.add_edge([e[0],e[1], r1 * r2 / (r1 + r2)])
    return G

# Check if given edge is a loop
def checkLoop(e):
    if e[0] == e[1]:
        return True
    else:
        return False

# Performs Y to delta reduction to graph with edges e1, e2 and e3 in forming a Y
def wye_to_delta_reduction(e1,e2,e3, G):
    G.allow_multiple_edges(True)
    if checkLoop(e1) or checkLoop(e2) or checkLoop(e3):
        print("Cannot perform Y to delta reduction (one edge is a loop)")
        return 
    vs = list({e1[0], e1[1]} & {e2[0], e2[1]} & {e3[0], e3[1]})
    if len(vs) != 1:
        print("Cannot perform Y to delta reduction (edges not incident at one vertex)")
        return 
    v = vs[0]
    if G.degree(v) != 3:
        print("Cannot perform Y to delta reduction (common vertex is not degree three)")
        return 
    G = copy(G)
    r1 = e1[2]
    r2 = e2[2]
    r3 = e3[2]
    R = (r1*r2 + r2*r3 + r3*r1)
    l1 = list(({e2[0], e2[1]} | {e3[0], e3[1]}) ^^ {v})
    l1 += [R/r1]
    G.add_edge(l1)
    l2 = list(({e1[0], e1[1]} | {e3[0], e3[1]}) ^^ {v})
    l2 += [R/r2]
    G.add_edge(l2)
    l3 = list(({e1[0], e1[1]} | {e2[0], e2[1]}) ^^ {v})
    l3 += [R/r3]
    G.add_edge(l3)
    G.delete_vertex(v)
    return G

# Performs delta to Y reduction to graph with edges e1, e2 and e3 in forming a triangle
def delta_to_wye_reduction(e1,e2,e3, G):
    G.allow_multiple_edges(True)
    if checkLoop(e1) or checkLoop(e2) or checkLoop(e3):
        print("Cannot perform delta to Y reduction (one edge is a loop)")
        return 
    v1 = list({e2[0], e2[1]} & {e3[0], e3[1]})
    v2 = list({e1[0], e1[1]} & {e3[0], e3[1]})
    v3 = list({e2[0], e2[1]} & {e1[0], e1[1]})
    if len(v1) != 1 or len(v2) != 1 or len(v3) != 1:
        print("Cannot perform delta to Y reduction (edges do not form triangle)")
        return
    G = copy(G)
    v = max(G.vertices()) + 1
    G.add_vertex(v)
    r1 = e1[2]
    r2 = e2[2]
    r3 = e3[2]
    R = r1 + r2 + r3
    v1 = v1[0]
    G.add_edge(v1,v,r2*r3/R)
    v2 = v2[0]
    G.add_edge(v2,v,r1*r3/R)
    v3 = v3[0]
    G.add_edge(v3,v,r1*r2/R)
    G.delete_edges([e1,e2,e3])
    return G

#TODO (notate)
def tau_first_term(G, polys):
    s = 0
    for e in G.edges():
        Gc = copy(G)
        Gc.delete_edge(e)
        if Gc.is_connected():
            s += e[2]^3/(e[2] + res(e[0],e[1],Gc,polys))^2
    return (1/12)*s

#TODO (notate)
def tau_second_term(G,polys):
    q = G.vertices()[0]
    s = 0 
    for e in G.edges():
        Gc = copy(G)
        Gc.delete_edge(e)
        if Gc.is_connected():
            J0 = j_functions(e[0],Gc,polys)
            R0 = J0[q,e[1]]
            J1 = j_functions(e[1],Gc,polys)
            R1 = J1[q,e[0]]
            s += e[2] * (R0 - R1)^2/(e[2] + res(e[0],e[1],Gc, polys))^2
        else:
            s += e[2]
    return (1/4)*s

#TODO (notate)
def tau(G,polys):
    return tau_first_term(G,polys) + tau_second_term(G,polys)

def helper_tau(G, C, V, E, active_vertices, F):
    if E == set(G.edges()):
        return 0
    s = 0
    active_vertices_copy = copy(active_vertices)
    for q in active_vertices:
        neighbors = G.neighbors(q)
        for v in neighbors:
            w = G.edge_label(q,v)
            if type(w) == type([]):
                w = w[0]
            e = (q,v,w)
            if e not in set(F.keys()):
                e = (v,q,w)
            if v not in V:
                V.add(v)
                C[v] = C[q] - F[e]
                active_vertices_copy.add(v)
            if e not in E:
                E.add(e)
                s += w*(1/3 * F[e]^2 - C[q] * F[e] + C[q]^2)
        active_vertices_copy.remove(q)
    active_vertices = active_vertices_copy
    s += helper_tau(G, C, V, E, active_vertices, F)
    return s

# Only works on connected, undirected graph
# F should be a dictionary of the fosters coefficients of G
#TODO NOT RIGHT
def tau_using_fosters(G,F):
    q = G.vertices()[0]
    C = {q:1/2}
    answer = helper_tau(G, C, {q}, set([]), {q}, F)
    return answer

def test_fosters(G,F,polys):
    return tau_using_fosters(G,F) - tau(G,polys)

#TODO (notate)
def tau_summand(e,G,polys):
    q = G.vertices()[0]
    Gc = copy(G)
    Gc.delete_edge(e)
    if Gc.is_connected():
        J0 = j_functions(e[0],Gc,polys)
        R0 = J0[q,e[1]]
        J1 = j_functions(e[1],Gc,polys)
        R1 = J1[q,e[0]]
        s = e[2]^3 + 3* e[2] * (R0 - R1)^2
    else:
        s = 3*e[2]
    return s/(12*(e[2] + res(e[0],e[1],Gc, polys))^2)

# EXAMPLES ****************************************************************************

# WORK on Random Graph ****************************************************************
if False:
    G = graphs.CompleteGraph(4)

    # G is a random graph on 4 verticies
    G = graphs.RandomGNP(4,2/3)

    # Assigning a variable z[i] to each edge of a compiled graph
    G.allow_multiple_edges(True)
    polys = PolynomialRing(QQ,len(G.edges()),"z").fraction_field()
    z = polys.gens()
    i = 0
    for u,v in G.edges(labels=0):
        G.set_edge_label(u,v,z[i])
        i += 1

# Work on K4 ****************************************************************

# WORK on Block Tower Graph *************************************************************
if False:
    T = {}
    R = {}
    Dif = {}
    for n in range(4,10):
        P = graphs.PathGraph(n)
        C = graphs.CycleGraph(4)
        G = P.cartesian_product(C)
        G.relabel()
        for e in G.edges():
            G.set_edge_label(e[0],e[1],1)
        T[n] = N(tau(G,QQ))
        R[n] = N(res(0,4*n - 2,G,QQ))
        if len(R) > 1:
            Dif[n] = R[n] - R[n-1]
        else:
            Dif[n] = R[n]
    # Calculating Tau constant
    P = graphs.PathGraph(4)
    C = graphs.CycleGraph(4)
    G = P.cartesian_product(C)
    polys = PolynomialRing(QQ,3,"z").fraction_field()
    z = polys.gens()
    for i in range(4):
        for k in range(4):
            if k < 3:
                G.set_edge_label((k,i),(k+1,i), z[1])
            if i < 3:
                G.set_edge_label((k,i),(k,i+1), z[2])
            G.set_edge_label((k,3),(k,0), z[2])
    for i in range(3):
        G.set_edge_label((0,i),(0,i+1), z[0])
    G.set_edge_label((0,3),(0,0), z[0])
    G.relabel()
    F = fosters(G)
    #p = tau_using_fosters(G, F) output:
    p = (1501674488153570875152290799799054766277688971906348058305038881696837571368237261401809921394693183901283568116886437695620434874938015834000568688681418752/3*z0^5*z1^8 + 22954167176061726234470730796928408570244674284854177462662737191651660019485912424284808798461738668205334541215264119061626647374052527748294407098415972352/3*z0^4*z1^9 + 158748445890520349658956455978757218149355691315813937592246967493665686116070796205334191690296136583849977200927994842108445972493447388165774404232035696640/3*z0^3*z1^10 + 562913408130709996628515865524674243816093694611751043570346003653214541038607796274049890534239273508138297534101430359044003015976764792631070319871434686464/3*z0^2*z1^11 + 955923074173187402811229686272084005504768865544955278258179036691586888288123605258066429962107546780588511361263709481669236828960542650900933439537771708416/3*z0*z1^12 + 200795331558820334163220598373130751605130982529191683224788056181177138114381439524584869489347545733085917108200815097585818148991711831517790327515115421696*z1^13 + 3003348976307141750304581599598109532555377943812696116610077763393675142736474522803619842789386367802567136233772875391240869749876031668001137377362837504*z0^5*z1^7*z2 + 141640082971913595759900000081046558490692020528738043642271703091476715213696950262935000085835167810117496549882038641219056018025403564914125068100272390144/3*z0^4*z1^8*z2 + 1017062678333725645585287240263902663846074773686856592060598476874958132265258979472282976761748626410855056634594085873562354534583019009856670879005515186176/3*z0^3*z1^9*z2 + 3793658806929678193741872929092354926693521682741694151866615369132410801725129675804229521420536323444328374082717109172764538618343410286923722384377458458624/3*z0^2*z1^10*z2 + 6837767519343845439229159564685010231476436898648991144344972759315000107113027781417327062076350077667073207165376902158600820171967759527562018054718791614464/3*z0*z1^11*z2 + 1532566077624158618869709353394921035755401430756992932647313967263172515693526713636361439777669729398681401518148101556787483820936740731157151815991436509184*z1^12*z2 + 22337408011284366767890325647010939648380623457106927367287453365240458874102529263351922580746061110531593075738685760722353968764702985530758459244136103936/3*z0^5*z1^6*z2^2 + 122413286400375911519110848233619375143886609942008551538616115981179705594571483898201112342263828294809990865242617644294772950073072183610939215425547796480*z0^4*z1^7*z2^2 + 2771568200622224074244245429454125070549642146872115412289370556716057007948593116215645841796975108248089555501303091030132026377705911313337138886994661736448/3*z0^3*z1^8*z2^2 + 3658534918611716700172365905160436409420784634001764011405917316902582863830048469372020232243610270700068233015913702752260406987364612755003564069694142939136*z0^2*z1^9*z2^2 + 21162401355535917328472056392268172117152841754053492381237271334558458361563003900492913524751906361742549443814654869169734393490595235926932799979838918098944/3*z0*z1^10*z2^2 + 15294661924307558904202878388153358441307282013792719712983842798573840438497737095753248464399335413261994661525353859818300959232306186841855363563412298661888/3*z1^11*z2^2 + 9948593484017407047883926548668737826589689438879555886270882591241548910314571856786990729239842343346003638774372649733485381046464354900253767562514399232*z0^5*z1^5*z2^3 + 174566307295870128587178911970390565118249473142657813679616339106896437230550063251216202893558540902667292285623501760603162115740841354060079501646963408896*z0^4*z1^6*z2^3 + 4213470681024110851526635225811178174791028105950262580916517801496782955270762505194873007570440236668730961594394173911046426443068269338516506368406957588480/3*z0^3*z1^7*z2^3 + 17894489513155148252198680131405464828810040963868867158497952256757265370985118148743039098311090655504802598955146251023047252125073874540748633840288029212672/3*z0^2*z1^8*z2^3 + 37215248002665870213461646746020074745276826946269070754944626085651877112433339930690354376963983830033560026856738142191713427288151377406119093527247260221440/3*z0*z1^9*z2^3 + 9709559084242390426792720831000724001828987305030034697132826937822877301186420661284566914252122789037145750806623976418864656823692971451248748468033931968512*z1^10*z2^3 + 23516457121123693900334116470290666242215840188955270959941019049697741498497121800624437401841113180704085252267959877819305950834478537025422968253608624128/3*z0^5*z1^4*z2^4 + 451790333995341373279565069716106578976927678151045074280359234130238793367610118527002006468175613330907544120442970624946269194849027367575649889012072579072/3*z0^4*z1^5*z2^4 + 1313703724879740635114812756336707906493492002784552999346043412036580300548621169560536044671542281296783166481040996505676232314855930896636542146440622768128*z0^3*z1^6*z2^4 + 6050908523287277971720371099874678066985353161498068076334026755202842337141612807569871765842690828795013691265933415224415636209089105657079396408117111554048*z0^2*z1^7*z2^4 + 13694305969789610514397722764367508647531344909446811639418758504651210683868158528602176748170133820132912458932214884788396895779872244253049043218046100963328*z0*z1^8*z2^4 + 35106870205682396819553631315052205441730696670980916896297596048626629718704274668588259643577238266029302517156913210694960629215972779282042402221040536125440/3*z1^9*z2^4 + 3730722556506527642956472455750776684971133539579833457351580971715580841367964446295121523464940878754751364540389743650057017892424133087595162835942899712*z0^5*z1^3*z2^5 + 244058347305765893295032041003669674697937800595515348287917977277763665740732347534465779793099874794786554436360706470644534720641903616096978865368200118272/3*z0^4*z1^4*z2^5 + 2359121822015305820034902251030409965235728216531053035839061952058534382211856001897039860281054819878542063928221658738348830412542027535278366062836348616704/3*z0^3*z1^5*z2^5 + 11940133966723369407841616479049116611250198585486340054975257298401024387065072471339861829758074240018441749607978268472342211064584299120495992747075980754944/3*z0^2*z1^6*z2^5 + 9899903029519820506516823476887753296377748121902074609719679477858673324239359770940734722726049233548347288081368425639809973821032770931493293766148804837376*z0*z1^7*z2^5 + 27961366678730508891695048728608374629936353368017689139147112107055327683572998836959375962609361420889887698782440080697164449925705222081069839054334102339584/3*z1^8*z2^5 + 1047066000528954692244859014703637796017841724551887220341599376495646509723556059219621370972471614556168425425250895033860342285845452446754302777068879872*z0^5*z1^2*z2^6 + 82399359609453473300069617379598803107190377571178127551972362297572566067320742139308018733671975877797552038467323336278101206056169138927051294173015572480/3*z0^4*z1^3*z2^6 + 303385488180274473900230771913113678699057962903090801288659676963785552819333639066341679475700470596855282356236389361460132868183949416460660512423816462336*z0^3*z1^4*z2^6 + 5146437388302748021896057532422857503578922007626908740772495568224918822937489014087353747176584001773520533018590885553286318430658360626685013564075773263872/3*z0^2*z1^5*z2^6 + 4745223505537638631083422333863459644341476786934593115252448140632197884093227498698149292118595991179453394463079074032528127075772394555931443235885189955584*z0*z1^6*z2^6 + 4975508891644369896860996638531862960571307150855995874199246116347545925886629764999866859068189823286011421329865496871277687710200144994716103548337655906304*z1^7*z2^6 + 158379731172446928238718170291306557380850008755747646774359569553963337605243773663472140147096546739588501324827866475709967740716118857492247478884368384*z0^5*z1*z2^7 + 5578905080849552511900879464097213787105867371912116182012163144473602751888414937378654883752884973115399193492283180222429154676283393088648876141125304320*z0^4*z1^2*z2^7 + 221718949072991925672884747337323063869272629420044426737238518071371404417281604228984488184137679534527413621518071153399007147785220732247243982379289673728/3*z0^3*z1^3*z2^7 + 478047745101643254197903510499897654403657210257402229283385350307263623923723916138110620782205268402176981432345038162864717160148663763161919179871479660544*z0^2*z1^4*z2^7 + 4480329005714744131189492896324296890828744568123695294143254695009595480744634919363390374607572930742304415205600999911167769641431888096807395653910003712000/3*z0*z1^5*z2^7 + 5305280212591275233117410208686953655067034409166194192008752917975309456783177749869454333310182078826029484584395646207362102155092538982503301536415265849344/3*z1^6*z2^7 + 9898733198277933014919885643206659836303125547234227923397473097122708600327735853967008759193534171224281332801741654731872983794757428593265467430273024*z0^5*z2^8 + 617649527022707217169048737515006028833453754383773808998023281663323293776005232411814467180790203604486506654661054678587185703130023044446453213784178688*z0^4*z1*z2^8 + 32174706214633304992193803745987539103794947066421019050715904049966739235339342185272882126846822712534466567252721368041525963088607237067199056868611719168/3*z0^3*z1^2*z2^8 + 247992753319458150469708214175115851912556462469768165408730366571567660411447796450263957914789702733815862573934249512153069273105638921881924342504864350208/3*z0^2*z1^3*z2^8 + 896628719579007509963001007470643426736757305124112992594368801651907852085627102946532241112751687234557806722416248232524867001460060438634073931014490554368/3*z0*z1^4*z2^8 + 407767158387867740498131684121411563498596502602221104539556345178987509166522931373287883650502993502216699282948240741957508155014723893480045187168072630272*z1^5*z2^8 + 28399936914106926864234433809676250244631586391469630113557035909602056817606956438167251321019544467441092871490711176075968917792101670130678305365426176*z0^4*z2^9 + 809286906771378946807100915126080993600824846327318994033533091517143350752720499552900631465917936580728016690224931475750800770352337495360518532976607232*z0^3*z1*z2^9 + 24456732026460644860211665184325000443491766183397049234590515528600619739246771757165546969321544498037363150510233253096561589342771024409205481146601701376/3*z0^2*z1^2*z2^9 + 107506422694766060457880542987371936329451328463146644554419102288855580900166823399641334738776092406544396148286547203802206006191424306144947660552853782528/3*z0*z1^3*z2^9 + 174764910450832403306716352215676489214012761248875338506523869360781565860245527665810080656600138159689950882522889085231433345129993312627411050072866029568/3*z1^4*z2^9 + 21624018355761913193307131137243119999543137356160485999326622777643059859049280109558882229904922862138757435346661829086889196742118906510288253255417856*z0^3*z2^10 + 1166708427247558677593841098122686545031359991334761238397213675999560199982146914200604892846983411500033333730113215629247233012597563562853460460460572672/3*z0^2*z1*z2^10 + 7059734617612040755624926271906870401982240767269262003737772426738404143241147231214968141199646799343945915204645315385862894061537210739685848766117576704/3*z0*z1^2*z2^10 + 14578110540077625740941140578615649376379859684893709901259627773643493784964146223663741021575260681954616865495771327440969236372231515670859664189837803520/3*z1^3*z2^10 + 7063976931839874155488463365753958970483513535360933815704942772351456732641287689438096859239301171131613464347274633237890839626020678209082962537873408*z0^2*z2^11 + 235697217330953799208429710930374449356207093883284837101954911668394017876322186649814979727834402931492444803920835352947679340329931841411867300545429504/3*z0*z1*z2^11 + 690816353890401780247583553618496525083800137396928393172553810323008076393242518062565320284458813325123125818280277385785209821443653349974452462461911040/3*z1^2*z2^11 + 3293030951543518721233268835008564747129941898319323178220191116304710599183102602212569712879859582093792004232325431435272560085160705411648498754912256/3*z0*z2^12 + 5977211250018355054644084386407196051947588376074636305596490038143540312234935737216851188587100990957519085216924689662830710452786727715377891378200576*z1*z2^12 + 72014593373715121140290173330207181348766125012947425368632410098114943520902840207431942031169891457319507050806321562202779644009478647173227606966272*z2^13)/(214524926879081553593184399971293538039669853129478294043576983099548224481176751628829988770670454843040509730983776813660062124991145119142938384097345536*z0^4*z1^8 + 2574299122548978643118212799655522456476038237553739528522923797194578693774121019545959865248045458116486116771805321763920745499893741429715260609168146432*z0^3*z1^9 + 11155296197712240786845588798507263978062832362732871290266003121176507673021191084699159416074863651838106506011156394310323230499539546195432795973061967872*z0^2*z1^10 + 20594392980391829144945702397244179651808305900429916228183390377556629550192968156367678921984363664931888934174442574111365963999149931437722084873345171456*z0*z1^11 + 13729595320261219429963801598162786434538870600286610818788926918371086366795312104245119281322909109954592622782961716074243975999433287625148056582230114304*z1^12 + 1287149561274489321559106399827761228238019118776869764261461898597289346887060509772979932624022729058243058385902660881960372749946870714857630304584073216*z0^4*z1^7*z2 + 16303894442810198073082014397818308891014908837840350347311850715565665060569433123791079146570954568071078739554767037838164721499327029054863317191398260736*z0^3*z1^8*z2 + 74654674553920380650428171190010151237805108889058446327164790118642782119449509566832836092193318285378097386382354331153701619496918501461742557665876246528*z0^2*z1^9*z2 + 145876950277775456443365391980479605866975500128045239949632348507692792647200191107604392364055909293267546617068968233288842244993978681017198101186194964480*z0*z1^10*z2 + 102971964901959145724728511986220898259041529502149581140916951887783147750964840781838394609921818324659444670872212870556829819995749657188610424366725857280*z1^11*z2 + 3191058287326338109698617949572991378340089065300989623898207623605779839157504180478846082963723015790227582248383680103193424109243283647251208463448014848*z0^4*z1^6*z2^2 + 43119510302695392272230064394230001145973640479025137102758973603009193120716527077394827742904761423451142455927739139545672487123220168947730615203566452736*z0^3*z1^7*z2^2 + 210556215731818544851710488571824607585935960846582945603770808912206582328274981723696633978413051428444260300960576942607350975678808934438794023991544643584*z0^2*z1^8*z2^2 + 438918000394600858651655282341266578829164519502912589613158507421675667288487633832586157024791750608860882909592807360748487107731882913766451933863168966656*z0*z1^9*z2^2 + 330368387393785592533503975955792048581091573819396572827108553973304265701012197508398182706832500458282384985715016293036495672486363483480125111509912125440*z1^10*z2^2 + 4263682921721745877664539949429459068538438330948381094116092539103520961563387938622996026817075290005430130903302564171493734734199009242965900383934742528*z0^4*z1^5*z2^3 + 62265860026653420930421772091667949416014174870831074846148219344643872155661552160267904240687099518192507949418041220164833031778679870831237865984254541824*z0^3*z1^6*z2^3 + 327901350734676154667182355356122172893635370508407572445607418667659461119478664864666637835969790227587419123808702859679404958048965314609981320092792651776*z0^2*z1^7*z2^3 + 736249549049007891931808860701479422552146935940369505157556205997649506419398611590144521460941001021315029396736322024481333212969610048898564534222089879552*z0*z1^8*z2^3 + 595950246870088555881866263120253448674202851993690700853056859050544967608709016024889708804922523553966536032672931988347652583225401140979082831022425899008*z1^9*z2^3 + 3359493874446241985762016638612952320316548598422181565705859864242534499785303114374919628834444740100583607466851411117043707262068362432203281179086946304*z0^4*z1^4*z2^4 + 53889332022421783392462899974038847047871441074415977083415424332678700077873103686510933272907326601743160546016034059893950293491916251257203443767703502848*z0^3*z1^5*z2^4 + 310340474298433838116015276114722065928169271124886685219133984066744880681089836711800382973945688463170399897548952754573700810036018294622639848307074007040*z0^2*z1^6*z2^4 + 759579134847108010885067664198357594813961032468200269634795202909725375831726583329779782739751412985495684829980807752966864969062397080605359083492676206592*z0*z1^7*z2^4 + 668137884764899498665972813710593724224551757571760146798720513863542945146624992947991000026253131608649667557148972886144263488284921473570681597271182671872*z1^8*z2^4 + 1598881095645654704124202481036047150701914374105642910293534702163820360586270476983623510056403233752036299088738461564310150525324628466112212643975528448*z0^4*z1^3*z2^5 + 28806675337481669868434792708645260404889417465542757172039071761836210018613015679658826929611592014392033447313665280259290217221467205529912694889571680256*z0^3*z1^4*z2^5 + 184836688170206157965452615119016243251898667361231587006952587172787308477586400235446438605954388928277856688994350075557137589974792426639047676785623826432*z0^2*z1^5*z2^5 + 500989447206270111924133231070460543476330243569345074755329735125385573865713119561690434088155430027351885397067144533175940708209789559333466511936835289088*z0*z1^6*z2^5 + 485416278295641785392978001035044453199262960168727009847103818508502744944782694748135057090834571696089913393783540985109305573323713618340683828616268611584*z1^7*z2^5 + 448742571655266296676368149158701912579075024807951665860685447069562789881524025379837730416773549095500753753678955014511575265362336762894701190172377088*z0^4*z1^2*z2^6 + 9409767202832838926944795419053340385341612424964499077403616965721980518355991187656765405882259911845710483473503241564800146880959252120531465293082394624*z0^3*z1^3*z2^6 + 69192668798460015156989202756366044671623202237894620074914654275506628497698298367158172549977576001522870658153634576187153631486401767529814149902022737920*z0^2*z1^4*z2^6 + 212470180313817850587674680640318492120633640317472509758440847308297864143567980554635101534476376892747012348716697826366724342450214307298647427387163148288*z0*z1^5*z2^6 + 231073513816613204063333640325329103622511260393544455570032288811461811735295026984947702123182955398666931551950447221926307854851790173099324115383104831488*z1^6*z2^6 + 67877027645334397816593501553417096020364289466748991474725529808841430402247331570059488634469948602680786282069085632447129031735479510353820348093300736*z0^4*z1*z2^7 + 1777372538713015528012281688824662477273983431592279147134479613883366344236624571112298461650750135633159848200846057116300749090258667178524110596369022976*z0^3*z1^2*z2^7 + 15734900593783259108668841711956948295980003250828960653344707076797722699543186973963049606042496603858483012572978036055058541097495046492761539211702566912*z0^2*z1^3*z2^7 + 56782066583306898716695995867401758349875114250208785954659282714161670667361471446755937652736836016267284919419768425365647693708593723723146503540766146560*z0*z1^4*z2^7 + 71306074523417217024809558446708241167467137275365496081078330648073271552938641209376567986226134154312511929800279439952976587264634845617620753826606743552*z1^5*z2^7 + 4242314227833399863537093847088568501272768091671811967170345613052589400140458223128718039654371787667549142629317852027945564483467469397113771755831296*z0^4*z2^8 + 169692569113335994541483753883542740050910723666872478686813824522103576005618328925148721586174871506701965705172714081117822579338698775884550870233251840*z0^3*z1*z2^8 + 2012009177487010977254827126293264784504872333452646031244641939148497214762911643206331261868670945617735405719109563006241442039467732152586699453975494656*z0^2*z1^2*z2^8 + 9123175308330315913941400634716690424366740980549336668954775839862427812213169121027625342758942351078836052504767102227801157635853894187926446045577347072*z0*z1^3*z2^8 + 13854455531608809865453584705958578376601022194490877482118977584315745294325372010466586735724588398124956044462323367422819559033119540057774219938599272448*z1^4*z2^8 + 5656418970444533151382791796118091335030357455562415956227127484070119200187277630838290719539162383556732190172423802703927419311289959196151695674441728*z0^3*z2^9 + 124441217349779729330421419514598009370667864022373151036996804649542622404120107878442395829861572438248108183793323659486403224848379102315337304837718016*z0^2*z1*z2^9 + 815362319739634186117845395203393017627338933964774922282814080296329775078847575526763980757274814696400062375965682967543907998501500784867496280182489088*z0*z1^2*z2^9 + 1621506771527432836729733648220519516042035803927892574118443212100100837387019587506976672934559883286263227849428156775125860202569788302896819426673295360*z1^3*z2^9 + 2828209485222266575691395898059045667515178727781207978113563742035059600093638815419145359769581191778366095086211901351963709655644979598075847837220864*z0^2*z2^10 + 36452477809531435864466880463872144159084525824735569495685932675118545956762455843180095748141268694032274114444508950758643368894979737041866483235291136*z0*z1*z2^10 + 108519445432972895274677264829228567094286117110419683900950075435123027618407770843490170100788374617866195352196871474097570489009192550503947346642993152*z1^2*z2^10 + 628490996716059239042532421790899037225595272840268439580791942674457688909697514537587857726573598172970243352491533633769713256809995466239077297160192*z0*z2^11 + 3770945980296355434255194530745394223353571637041610637484751656046746133458185087225527146359441589037821460114949201802618279540859972797434463782961152*z1*z2^11 + 52374249726338269920211035149241586435466272736689036631732661889538140742474792878132321477214466514414186946040961136147476104734166288853256441430016*z2^12)

# WORK ON SQUARE GRID GRAPH *************************************************************
if False:
    n = 5
    G = graphs.Grid2dGraph(n,n)

# WORK ON LADDER GRAPH *************************************************************
if False:
    n = 3
    G = graphs.LadderGraph(n)
    

# WORK ON BANANA GRAPH ****************************************************************
if False:
    answer = []
    answer_with_fosters = []
    f = []
    p = []
    for edge_num in range(3,10):
        polys = PolynomialRing(QQ,edge_num,"z").fraction_field()
        z = polys.gens()
        G = Graph([(0, 1, 1/edge_num) for i in range(edge_num)])
        p += [tau(G,polys)]
        answer += [1/12*(1 - (2*edge_num - 4)/edge_num^2)]
    #testing tau_with_fosters
    for edge_num in range(3,10):
        polys = PolynomialRing(QQ,edge_num,"z").fraction_field()
        z = polys.gens()
        G = Graph([(0, 1, 1/edge_num) for i in range(edge_num)])
        p += [tau_using_fosters(G)]
        answer_with_fosters += [1/12*(1 - (2*edge_num - 4)/edge_num^2)]

# Banana graph on three edges
if False:
    edge_num = 3
    polys = PolynomialRing(QQ,edge_num,"z").fraction_field()
    z = polys.gens()
    G = Graph([(0, 1, z[0]), (0,1,z[1]), (0,1,z[2])])
    p = tau(G, polys)
    var('x, y')
    S = {z[0]:x,z[1]:y,z[2]:1-x-y}
    f = p.substitute(S)
    graphic = contour_plot(f, (x,0,1), (y,0,1), fill=False, region=1-x-y,plot_points=300)
    show(graphic)

# WORK ON Cube Graph ****************************************************************
if False:
    dimensions = 3
    edge_num = dimensions * 2^dimensions / 2
    polys = PolynomialRing(QQ,edge_num,"z").fraction_field()
    var('x,y')
    z = polys.gens()
    G = Graph([(0, 1, z[0]),
     (0, 2, z[1]),
     (0, 4, z[2]),
     (1, 3, z[2]),
     (1, 5, z[1]),
     (2, 3, z[0]),
     (2, 6, z[2]),
     (3, 7, z[1]),
     (4, 5, z[0]),
     (4, 6, z[1]),
     (5, 7, z[2]),
     (6, 7, z[0])])
    p = tau(G,polys)
    f = p.substitute({z[0]:x, z[1]:y, z[2]:1/4-x-y})
    graphic = contour_plot(f, (x,0,1/4), (y,0,1/4), fill=False,
                           region=1/4-x-y, plot_points=300)
    show(graphic)

# WORK ON Peterson Graph ****************************************************************
if False:
    G = graphs.PetersenGraph()
    edge_num = len(G.edges())
    polys = PolynomialRing(QQ,edge_num,"z").fraction_field()
    z = polys.gens()
    S = {0,1,2,3,4}
    for e in G.edges():
        u = e[0]
        v = e[1]
        if u in S and v in S:
            G.set_edge_label(u,v,z[0])
        elif not u in S and not v in S:
            G.set_edge_label(u,v,z[1])
        else:
            G.set_edge_label(u,v,1/5 - z[1] - z[0])
    p = tau(G,polys)
    vars('x,y')
    f = p.substitute({z[0]:x, z[1]:y})
    graphic = contour_plot(f, (x,0,1/5), (y,0,1/5), fill=False,
                           region=1/5-x-y, plot_points=300)
    show(graphic)

# WORK ON Diamond Necklace ************************************************************
# Page 56 of Cinkir
if False:
    t = 4
    # polys = PolynomialRing(QQ,2,"z").fraction_field()
    # z = polys.gens()
    polys = QQ
    a = 1/100
    b = 1/5 * (1 - t * a)
    es = []
    v = '00'
    vs = [v]
    for i in range(t - 1):
        vs += [str(i) + '1', str(i) + '2', str(i) + '3']
        vs += [str(i + 1) + '0']
        es += [(str(i) + '0', str(i) + '1', a),
               (str(i) + '1', str(i) + '2', b),
               (str(i) + '1', str(i) + '3', b),
               (str(i) + '2', str(i) + '3', b),
               (str(i + 1) + '0', str(i) + '2', b),
               (str(i + 1) + '0', str(i) + '3', b)]
    n = t - 1
    vs += [str(n) + '1', str(n) + '2', str(n) + '3']
    es += [(str(n) + '0', str(n) + '1', a),
           (str(n) + '1', str(n) + '2', b),
           (str(n) + '1', str(n) + '3', b),
           (str(n) + '2', str(n) + '3', b),
           ('00', str(n) + '2', b),
           ('00', str(n) + '3', b)]
    G = Graph(es)
    G.relabel()
    # p = tau_using_fosters(G)
    # p = tau(G,polys)
    # f = p.substitute({z[0]:x, z[1]:y})
    # graphic = contour_plot(f, (x,0,1/5), (y,0,1/5), fill=False,
    #                        region=1/5-x-y, plot_points=300)
    # show(graphic)




# *************************************************************************************

H = visualize(G)
show(H)

# CELL MEMBERSHIP

#TODO
D = DiGraph(G)

# V is vertex set of D. V is number of verticies
Vs = D.vertices()
V = len(Vs)

# l:E \to R is weight vector
def l(e):
    return e[2]

# Es is ordered list of edges of D. E is number of edges
Es = D.edges()

# Returns a vector representing edge set C with entries {-1,0,1} consistant with
# orientation of Es
def vec(C, Es):
    E = len(Es)
    v = []
    for i in srange(E):
        e = Es[i]
        er = (e[1], e[0], e[2])
        if e in C and (er not in C):
            v.append(1)
        elif er in C and (e not in C):
            v.append(-1)
        else:
            v.append(0)
    return vector(v)

def vecToEdgeSet(v,Es):
    C = []
    for i in srange(len(Es)):
        if v[i] == 1:
            C.append(Es[i])
        if v[i] == 2:
            er = (Es[i][1], Es[i][0], Es[i][2])
            C.append(er)
    return C


# Helps return fundamental cycles of tree T
def fundCycleHelper(T,P,v,s):
    if v == s:
        return P
    for e in T:
        if s in (e[0], e[1]):
            T.remove(e)
            if s == e[0]:
                P.append(e)
                s = e[1]
            else:
                P.append((e[1], e[0], e[2]))
                s = e[0]
            return fundCycleHelper(T,P, v,s)
    for e in P:
        if s in (e[0], e[1]):
            P.remove(e)
            return fundCycleHelper(T, P, v, e[0])

# Returns fundamental cycle of edge e with respect to tree T as a list of
# oriented edges
def fundCycle(T,e):
    if e in T:
        return []
    Tc = copy(T)
    return fundCycleHelper(Tc,[e],e[0], e[1])

# Returns a basis for the cycle space consisting of the fundamental cycles of tree T
def TBasis(T,Es):
    Basis = []
    for i in srange(len(Es)):
        e = Es[i]
        er = (e[1], e[0], e[2])
        if e not in T and er not in T:
            C = fundCycle(T,e)
            Basis.append(vec(C))
    return Basis

# Returns the minimal cycles of a directed graph D
def minimalCycles(D):
    Es = D.edges()
    S = set()
    T = D.min_spanning_tree()
    B = TBasis(T,D)
    C2 = VectorSpace(GF(3),len(Es))
    H2 = C2.subspace(B)
    for v in H2:
        C = vecToEdgeSet(v,Es)
        minimal = True
        for Co in S:
            if all(e in Co for e in C):
                S.remove(Co)
            if all(e in C for e in Co):
                minimal = False
                break
        if minimal:
            S.add(tuple(C))
    return S
    
# Returns the f cost of a vector
def fCost(f,C,E):
    Cv = vec(C)
    return sum(l(e)*(1 - 2*Cv[e]*f[e]) for e in srange(E))

# Checks whether the given flow is in the Voronoi polytope
def isVoronoi(f, D):
    for C in minimalCycles(D):
        if fCost(f, C) < 0:
            return False
    return True

# Returns the tree corresponding to the cell containing f
# TODO
def cellMembership(D, f):
    return True

